for (i in (k+dnevi):length(delnice[,1])) {
if (sd(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]) == 0) {
sharp[i,j] <- 0 #drugače deli z 0 in pride čudn, sm kr poenostavu pa dau na 0 ker je nerealno da skos isto kotira
}
else {
sharp[i,j] <- mean(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])])/sd(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]) #length(delnice[1,]), ker zadnji stolpec je benchmark
}
}
for (i in 1:(k+dnevi-1)) {sharp[i,j] <- NA}
}
sharp <- delnice
for (j in 4:(length(delnice[1,])-1)) { #do -1, ker zadnji stolpec je benchmark!
k <- 1
while (delnice[k,j] == 0) { #začnemo pri tistem k-ju, ko delnica začne kotirati na borzi
k <- k+1
}
for (i in (k+dnevi):length(delnice[,1])) {
#     if (sd(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]) == 0) {
#       sharp[i,j] <- 0 #drugače deli z 0 in pride čudn, sm kr poenostavu pa dau na 0 ker je nerealno da skos isto kotira
#     }
#     else {
sharp[i,j] <- mean(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])])/sd(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]) #length(delnice[1,]), ker zadnji stolpec je benchmark
#     }
}
for (i in 1:(k+dnevi-1)) {sharp[i,j] <- NA}
}
sharp <- delnice
for (j in 4:(length(delnice[1,])-1)) { #do -1, ker zadnji stolpec je benchmark!
k <- 1
while (delnice[k,j] == 0) { #začnemo pri tistem k-ju, ko delnica začne kotirati na borzi
k <- k+1
}
for (i in (k+dnevi):length(delnice[,1])) {
if (sd(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]) != 0) {
sharp[i,j] <- mean(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])])/sd(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]) #length(delnice[1,]), ker zadnji stolpec je benchmark
}
else {sharp[i,j] <- 0}
#     if (sd(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]) == 0) {
#       sharp[i,j] <- 0 #drugače deli z 0 in pride čudn, sm kr poenostavu pa dau na 0 ker je nerealno da skos isto kotira
#     }
#     else {
#     }
}
for (i in 1:(k+dnevi-1)) {sharp[i,j] <- NA}
}
sd(delnice[(50-(dnevi-1)):50,j]-delnice[(50-(dnevi-1)):50,length(delnice[1,])]
)
sd(delnice[(50-(dnevi-1)):50,j]-delnice[(50-(dnevi-1)):50,length(delnice[1,])])
sd(delnice[(500-(dnevi-1)):500,j]-delnice[(500-(dnevi-1)):500,length(delnice[1,])])
for (i in 91:length(delnice$BEI)) {sd(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])])}
for (i in 91:length(delnice$BEI)) {print(sd(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]))}
for (i in 91:length(delnice$BAYN)) {print(sd(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]))}
for (i in 91:length(delnice$BAYN)) {if (sd(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])] == 0) {print(sd(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]))}}
for (i in 91:length(delnice$BAYN)) {
if (sd(delnice[(i-(dnevi-1)):i,9]-delnice[(i-(dnevi-1)):i,length(delnice[1,])] == 0) {
print(sd(delnice[(i-(dnevi-1)):i,9]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]))
}
}
for (i in 91:length(delnice$BAYN)) {
if (sd(delnice[(i-(dnevi-1)):i,9]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]) == 0) {
print(sd(delnice[(i-(dnevi-1)):i,9]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]))
}
}
for (i in 91:length(delnice$BAYN)) {
if (sd(delnice[(i-(dnevi-1)):i,9]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]) != 0) {
print(sd(delnice[(i-(dnevi-1)):i,9]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]))
}
}
sharp <- delnice
for (j in 4:(length(delnice[1,])-1)) { #do -1, ker zadnji stolpec je benchmark!
k <- 1
while (delnice[k,j] == 0) { #začnemo pri tistem k-ju, ko delnica začne kotirati na borzi
k <- k+1
}
for (i in (k+dnevi):length(delnice[,1])) {
if (sd(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]) != 0) {
sharp[i,j] <- mean(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])])/sd(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]) #length(delnice[1,]), ker zadnji stolpec je benchmark
}
else {sharp[i,j] <- 0}
#     if (sd(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]) == 0) {
#       sharp[i,j] <- 0 #drugače deli z 0 in pride čudn, sm kr poenostavu pa dau na 0 ker je nerealno da skos isto kotira
#     }
#     else {
#     }
}
for (i in 1:(k+dnevi-1)) {sharp[i,j] <- NA}
}
sharp <- delnice
for (j in 4:(length(delnice[1,])-1)) { #do -1, ker zadnji stolpec je benchmark!
k <- 1
while (delnice[k,j] == 0) { #začnemo pri tistem k-ju, ko delnica začne kotirati na borzi
k <- k+1
}
for (i in (k+dnevi):length(delnice[,1])) {
sharp[i,j] <- mean(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])])/sd(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]) #length(delnice[1,]), ker zadnji stolpec je benchmark
#     if (sd(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]) == 0) {
#       sharp[i,j] <- 0 #drugače deli z 0 in pride čudn, sm kr poenostavu pa dau na 0 ker je nerealno da skos isto kotira
#     }
#     else {
#     }
}
for (i in 1:(k+dnevi-1)) {sharp[i,j] <- NA}
}
View(sharp)
View(delnice)
sharp <- delnice
for (j in 4:(length(delnice[1,])-1)) { #do -1, ker zadnji stolpec je benchmark!
k <- 1
while (delnice[k,j] == 0) { #začnemo pri tistem k-ju, ko delnica začne kotirati na borzi
k <- k+1
}
for (i in (k+dnevi):length(delnice[,1])) {
sharp[i,j] <- mean(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])])/sd(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]) #length(delnice[1,]), ker zadnji stolpec je benchmark
#     if (sd(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]) == 0) {
#       sharp[i,j] <- 0 #drugače deli z 0 in pride čudn, sm kr poenostavu pa dau na 0 ker je nerealno da skos isto kotira
#     }
#     else {
#     }
}
for (i in 1:(k+dnevi-1)) {sharp[i,j] <- NA}
}
View(sharp)
sharp <- delnice
View(sharp)
sharp <- delnice
for (j in 4:(length(delnice[1,])-1)) { #do -1, ker zadnji stolpec je benchmark!
k <- 1
while (delnice[k,j] == 0) { #začnemo pri tistem k-ju, ko delnica začne kotirati na borzi
k <- k+1
}
for (i in (k+dnevi):length(delnice[,1])) {
sharp[i,j] <- mean(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,11])/sd(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,11]) #11, ker zadnji stolpec je benchmark
}
for (i in 1:(k+dnevi-1)) {sharp[i,j] <- NA}
}
View(sharp)
sharp <- sharp[(dnevi+1):length(sharp[,1]),] #zbrišem prvih 90 vrstic, kjer sharpov ni izračunan
View(sharp)
sharp[ is.nan(sharp) ] <- 0 #tiste k napiše pol NaN (ne vem zakaj), jih kr dam na 0
sharp[is.nan(sharp)] <- 0 #tiste k napiše pol NaN (ne vem zakaj), jih kr dam na 0
sharp[is.na(sharp)] <- 0 #tiste k napiše pol NaN (ne vem zakaj), jih kr dam na 0
sharp <- as.data.frame(sharp)
View(sharp)
sharp <- delnice
for (j in 4:(length(delnice[1,])-1)) { #do -1, ker zadnji stolpec je benchmark!
k <- 1
while (delnice[k,j] == 0) { #začnemo pri tistem k-ju, ko delnica začne kotirati na borzi
k <- k+1
}
for (i in (k+dnevi):length(delnice[,1])) {
sharp[i,j] <- mean(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,11])/sd(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,11]) #11, ker zadnji stolpec je benchmark
}
for (i in 1:(k+dnevi-1)) {sharp[i,j] <- NA}
}
sharp <- sharp[(dnevi+1):length(sharp[,1]),] #zbrišem prvih 90 vrstic, kjer sharpov ni izračunan
View(sharp)
sharp[is.nan(sharp)] <- 0 #tiste k napiše pol NaN (ne vem zakaj), jih kr dam na 0
View(sharp)
sharp <- as.data.frame(sharp)
View(sharp)
sharp[is.na(sharp)] <- 0 #tiste k napiše pol NaN (ne vem zakaj), jih kr dam na 0
View(sharp)
n <- 10
invest <- sharp
invest[is.na(invest)] <- 0
for (j in 4:(length(sharp[1,])-1)) { #do -1, ker zadnji stolpec je benchmark!
k <- 1
while (invest[k,j] == 0) { #začnemo pri tistem k-ju, ko delnica začne kotirati na borzi
k <- k+1
}
for (i in (k+n):length(sharp[,1])) {
invest[i,j] <- mean(sharp[(i-(n-1)):i,j])
}
for (i in 1:(k+n-1)) {invest[i,j] <- NA}
}
invest <- invest[(n+1):length(invest[,1]),] #izbrišem prvih n vrstic, kjer ni izračuna
View(invest)
invest <- sharp
invest[is.na(invest)] <- 0
for (j in 4:(length(sharp[1,])-1)) { #do -1, ker zadnji stolpec je benchmark!
k <- 1
while (invest[k,j] == 0) { #začnemo pri tistem k-ju, ko delnica začne kotirati na borzi
k <- k+1
}
for (i in (k+n):length(sharp[,1])) {
invest[i,j] <- mean(sharp[(i-(n-1)):i,j])
}
for (i in 1:(k+n-1)) {invest[i,j] <- NA}
}
invest <- invest[(n+1):length(invest[,1]),] #izbrišem prvih n vrstic, kjer ni izračuna
#write.csv2(invest,file="C:/zan/faks/opb/ODP/invest.csv") #tabela povprečnih sharpovih vrednosti desetih prejšnjih dni
#prikažem samo tiste sharpove, pri katerih trejdam
trade <- invest[seq(1, length(invest[,1]), n), ]
trade[is.na(trade)] <- -Inf #tiste, ki še ne kotirajo, sem dal na -inf, da jih prikaže na zadnjem mestu po velikosti sharpa
trade <- trade[,-length(trade[1,])] #izbrišem benchmark
#razpredelnica, kam naj investiram v določenih datumih
for (i in 1:length(trade[,1])) {
trade[i,4:length(trade[1,])] <- colnames(tail(sort(trade[i,4:length(trade[1,])])))
}
colnames(trade) <- c("leto", "mesec", "dan", seq(length(trade[1,])-3, 1, -1))
trade <- trade[,c(1,2,3,length(trade[1,]):4)] #tak vrstni red, kot hočem - 1 pomeni največji sharpov
View(trade)
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8', echo=TRUE)
View(delnice)
View(invest)
View(sharp)
View(trade)
View(sharp)
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8', echo=TRUE)
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8', echo=TRUE)
delnice <- read.csv2(file="C:/zan/faks/opb/ODP/projekt.csv", header = TRUE, fileEncoding = "Windows-1250")
rownames(delnice)<- delnice[,1]
delnice[,1] <- NULL
######benchmark mora biti na zadnjem mestu pri vnašanju tickerjev (SP500 je GSPC)!!!!
#vse NA-je nadomestim z 0 (problem bo, če kje vmes NA, sepravi da ob določenem datumu ne bo podatka -
#UPAM DA TO NI MOŽNO!!! - DRUGAČE TREBA NAREDITI ŠE ENO ZANKO KI JE POMOJE DOST ZAJEBANA)
delnice[is.na(delnice)] <- 0
View(delnice)
for (j in 1:length(delnice[1,])) {
zacni <- 1
while (delnice[zacni,j] == 0) {
zacni <- zacni + 1
}
for (i in zacni:length(delnice[,1])) {
if (delnice[i,j] == 0) {
k <- 0 #nastavim števec, da vidimo, koliko zaporednih niičel je od i naprej in kje se končajo
while (delnice[i+k+1,j] ==0) {
k <- k+1
}
l <- 0 #nastavim števec, da vidimo, koliko zaporednih niičel je od i nazaj in kje se končajo
while (delnice[i-l-1,j] ==0 & (i-l)>0) {
l <- l+1
}
delnice[(i-l):(i+k),j] <- (delnice[i+k+1,j]+delnice[i-l-1,j])/2
}
#else {break}
}
}
delnice <- read.csv2(file="C:/zan/faks/opb/ODP/projekt.csv", header = TRUE, fileEncoding = "Windows-1250")
rownames(delnice)<- delnice[,1]
delnice[,1] <- NULL
######benchmark mora biti na zadnjem mestu pri vnašanju tickerjev (SP500 je GSPC)!!!!
#vse NA-je nadomestim z 0 (problem bo, če kje vmes NA, sepravi da ob določenem datumu ne bo podatka -
#UPAM DA TO NI MOŽNO!!! - DRUGAČE TREBA NAREDITI ŠE ENO ZANKO KI JE POMOJE DOST ZAJEBANA)
delnice[is.na(delnice)] <- 0
for (j in 1:length(delnice[1,])) {
zacni <- 1
while (delnice[zacni,j] == 0) {
zacni <- zacni + 1
}
for (i in zacni:length(delnice[,1])) {
if (delnice[i,j] == 0) {
k <- 0 #nastavim števec, da vidimo, koliko zaporednih niičel je od i naprej in kje se končajo
while (delnice[i+k+1,j] ==0) {
k <- k+1
}
l <- 0 #nastavim števec, da vidimo, koliko zaporednih niičel je od i nazaj in kje se končajo
while (delnice[i-l-1,j] ==0 & (i-l)>0) {
l <- l+1
}
delnice[(i-l):(i+k),j] <- (delnice[i+k+1,j]+delnice[i-l-1,j])/2
}
#else {break}
}
}
delnice <- read.csv2(file="C:/zan/faks/opb/ODP/projekt.csv", header = TRUE, fileEncoding = "Windows-1250")
rownames(delnice)<- delnice[,1]
delnice[,1] <- NULL
######benchmark mora biti na zadnjem mestu pri vnašanju tickerjev (SP500 je GSPC)!!!!
#vse NA-je nadomestim z 0 (problem bo, če kje vmes NA, sepravi da ob določenem datumu ne bo podatka -
#UPAM DA TO NI MOŽNO!!! - DRUGAČE TREBA NAREDITI ŠE ENO ZANKO KI JE POMOJE DOST ZAJEBANA)
delnice[is.na(delnice)] <- 0
for (j in 1:length(delnice[1,])) {
zacni <- 1
while (delnice[zacni,j] == 0) {
zacni <- zacni + 1
}
for (i in zacni:length(delnice[,1])) {
if (delnice[i,j] == 0) {
k <- 0 #nastavim števec, da vidimo, koliko zaporednih niičel je od i naprej in kje se končajo
#       while (delnice[i+k+1,j] ==0) {
#         k <- k+1
#       }
l <- 0 #nastavim števec, da vidimo, koliko zaporednih niičel je od i nazaj in kje se končajo
while (delnice[i-l-1,j] ==0 & (i-l)>0) {
l <- l+1
}
delnice[(i-l):(i+k),j] <- (delnice[i+k+1,j]+delnice[i-l-1,j])/2
}
#else {break}
}
}
View(delnice)
delnice <- read.csv2(file="C:/zan/faks/opb/ODP/projekt.csv", header = TRUE, fileEncoding = "Windows-1250")
rownames(delnice)<- delnice[,1]
delnice[,1] <- NULL
######benchmark mora biti na zadnjem mestu pri vnašanju tickerjev (SP500 je GSPC)!!!!
#vse NA-je nadomestim z 0 (problem bo, če kje vmes NA, sepravi da ob določenem datumu ne bo podatka -
#UPAM DA TO NI MOŽNO!!! - DRUGAČE TREBA NAREDITI ŠE ENO ZANKO KI JE POMOJE DOST ZAJEBANA)
delnice[is.na(delnice)] <- 0
for (j in 1:length(delnice[1,])) {
zacni <- 1
while (delnice[zacni,j] == 0) {
zacni <- zacni + 1
}
for (i in zacni:length(delnice[,1])) {
if (delnice[i,j] == 0) {
k <- 0 #nastavim števec, da vidimo, koliko zaporednih niičel je od i naprej in kje se končajo
while (delnice[i+k+1,j] ==0) {
k <- k+1
}
l <- 0 #nastavim števec, da vidimo, koliko zaporednih niičel je od i nazaj in kje se končajo
while (delnice[i-l-1,j] ==0 & (i-l)>0) {
l <- l+1
}
delnice[(i-l):(i+k),j] <- (delnice[i+k+1,j]+delnice[i-l-1,j])/2
}
#else {break}
}
}
source.with.encoding('C:/zan/faks/opb/ODP/koda_popravljena_urejene_tabele.R', encoding='UTF-8', echo=TRUE)
View(delnice)
View(invest)
View(sharp)
View(trade)
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8', echo=TRUE)
delnice <- read.csv2(file="C:/zan/faks/opb/ODP/proba.csv", header = TRUE, fileEncoding = "Windows-1250")
rownames(delnice)<- delnice[,1]
View(delnice)
rownames(delnice)
delnice <- read.csv2(file="C:/zan/faks/opb/ODP/proba.csv", header = TRUE, fileEncoding = "Windows-1250")
rownames(delnice)<- delnice[,1]
delnice[,1] <- NULL
View(delnice)
delnice <- read.csv2(file="C:/zan/faks/opb/ODP/proba.csv", header = TRUE, fileEncoding = "Windows-1250")
rownames(delnice)<- delnice[,1]
delnice[,1] <- NULL
View(delnice)
delnice <- read.csv2(file="C:/zan/faks/opb/ODP/proba.csv", header = TRUE, fileEncoding = "Windows-1250")
delnice <- cbind(dan = substr(row.names(delnice), 9, 10), delnice)
View(delnice)
delnice <- read.csv2(file="C:/zan/faks/opb/ODP/projekt.csv", header = TRUE, fileEncoding = "Windows-1250")
rownames(delnice)<- delnice[,1]
delnice[,1] <- NULL
View(delnice)
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8', echo=TRUE)
View(delnice)
View(invest)
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8', echo=TRUE)
View(trade)
n <- 365
invest <- sharp
invest[is.na(invest)] <- 0
for (j in 4:(length(sharp[1,])-1)) { #do -1, ker zadnji stolpec je benchmark!
k <- 1
while (invest[k,j] == 0) { #začnemo pri tistem k-ju, ko delnica začne kotirati na borzi
k <- k+1
}
for (i in (k+n):length(sharp[,1])) {
invest[i,j] <- mean(sharp[(i-(n-1)):i,j])
}
for (i in 1:(k+n-1)) {invest[i,j] <- NA}
}
invest <- invest[(n+1):length(invest[,1]),] #izbrišem prvih n vrstic, kjer ni izračuna
#write.csv2(invest,file="C:/zan/faks/opb/ODP/invest.csv") #tabela povprečnih sharpovih vrednosti desetih prejšnjih dni
#prikažem samo tiste sharpove, pri katerih trejdam
trade <- invest[seq(1, length(invest[,1]), n), ]
trade[is.na(trade)] <- -Inf #tiste, ki še ne kotirajo, sem dal na -inf, da jih prikaže na zadnjem mestu po velikosti sharpa
trade <- trade[,-length(trade[1,])] #izbrišem benchmark
#razpredelnica, kam naj investiram v določenih datumih
for (i in 1:length(trade[,1])) {
trade[i,4:length(trade[1,])] <- colnames(tail(sort(trade[i,4:length(trade[1,])])))
}
colnames(trade) <- c("leto", "mesec", "dan", seq(length(trade[1,])-3, 1, -1))
trade <- trade[,c(1,2,3,length(trade[1,]):4)] #tak vrstni red, kot hočem - 1 pomeni največji sharpov
#write.csv2(trade,file="C:/zan/faks/opb/ODP/trade.csv") #tabela delnic, ki padajo po sharpovih vrednostih
#lahko bi še pogledal, kakšne standardne odklone imajo sharpove in ali je trend naraščanja/padanja...
#plot(rownames(sharp), sharp[,8], type="l")
View(trade)
n <- 250
invest <- sharp
invest[is.na(invest)] <- 0
for (j in 4:(length(sharp[1,])-1)) { #do -1, ker zadnji stolpec je benchmark!
k <- 1
while (invest[k,j] == 0) { #začnemo pri tistem k-ju, ko delnica začne kotirati na borzi
k <- k+1
}
for (i in (k+n):length(sharp[,1])) {
invest[i,j] <- mean(sharp[(i-(n-1)):i,j])
}
for (i in 1:(k+n-1)) {invest[i,j] <- NA}
}
invest <- invest[(n+1):length(invest[,1]),] #izbrišem prvih n vrstic, kjer ni izračuna
#write.csv2(invest,file="C:/zan/faks/opb/ODP/invest.csv") #tabela povprečnih sharpovih vrednosti desetih prejšnjih dni
#prikažem samo tiste sharpove, pri katerih trejdam
trade <- invest[seq(1, length(invest[,1]), n), ]
trade[is.na(trade)] <- -Inf #tiste, ki še ne kotirajo, sem dal na -inf, da jih prikaže na zadnjem mestu po velikosti sharpa
trade <- trade[,-length(trade[1,])] #izbrišem benchmark
#razpredelnica, kam naj investiram v določenih datumih
for (i in 1:length(trade[,1])) {
trade[i,4:length(trade[1,])] <- colnames(tail(sort(trade[i,4:length(trade[1,])])))
}
colnames(trade) <- c("leto", "mesec", "dan", seq(length(trade[1,])-3, 1, -1))
trade <- trade[,c(1,2,3,length(trade[1,]):4)] #tak vrstni red, kot hočem - 1 pomeni največji sharpov
#write.csv2(trade,file="C:/zan/faks/opb/ODP/trade.csv") #tabela delnic, ki padajo po sharpovih vrednostih
#lahko bi še pogledal, kakšne standardne odklone imajo sharpove in ali je trend naraščanja/padanja...
#plot(rownames(sharp), sharp[,8], type="l")
View(trade)
delnice <- read.csv2(file="C:/zan/faks/opb/ODP/projekt1.csv", header = TRUE, fileEncoding = "Windows-1250")
rownames(delnice)<- delnice[,1]
delnice[,1] <- NULL
######benchmark mora biti na zadnjem mestu pri vnašanju tickerjev!!!!
#vse NA-je nadomestim z 0 (problem bo, če kje vmes NA, sepravi da ob določenem datumu ne bo podatka -
#UPAM DA TO NI MOŽNO!!! - DRUGAČE TREBA NAREDITI ŠE ENO ZANKO KI JE POMOJE DOST ZAJEBANA)
delnice[is.na(delnice)] <- 0
#spremenim datum v tri stolpce z letom, mesecem in dnevom
delnice <- cbind(dan = substr(row.names(delnice), 9, 10), delnice)
delnice <- cbind(mesec = substr(row.names(delnice), 6, 7), delnice)
delnice <- cbind(leto = substr(row.names(delnice), 1, 4), delnice)
#delnice <- cbind(indeks = c(1:length(delnice[,1])), delnice)
#zbriše prvo vrstico, kjer so bili prej datumi so zdaj rownames kar indeksi
rownames(delnice) <- c(1:length(delnice[,1]))
delnice <- read.csv2(file="C:/zan/faks/opb/ODP/projekt1.csv", header = TRUE, fileEncoding = "Windows-1250")
rownames(delnice)<- delnice[,1]
delnice[,1] <- NULL
######benchmark mora biti na zadnjem mestu pri vnašanju tickerjev!!!!
#vse NA-je nadomestim z 0 (problem bo, če kje vmes NA, sepravi da ob določenem datumu ne bo podatka -
#UPAM DA TO NI MOŽNO!!! - DRUGAČE TREBA NAREDITI ŠE ENO ZANKO KI JE POMOJE DOST ZAJEBANA)
delnice[is.na(delnice)] <- 0
#spremenim datum v tri stolpce z letom, mesecem in dnevom
delnice <- cbind(dan = substr(row.names(delnice), 9, 10), delnice)
delnice <- cbind(mesec = substr(row.names(delnice), 6, 7), delnice)
delnice <- cbind(leto = substr(row.names(delnice), 1, 4), delnice)
#delnice <- cbind(indeks = c(1:length(delnice[,1])), delnice)
#zbriše prvo vrstico, kjer so bili prej datumi so zdaj rownames kar indeksi
rownames(delnice) <- c(1:length(delnice[,1]))
#i vrstica, j stolpec - vse damo na procentualne spremembe
View(delnice)
for (j in 4:((length(delnice[1,])))) { #4, ker imamo še stolpec leto, mesec, dan
i <- length(delnice[,1])
while (i>1 & delnice[i,j] != 0) {
delnice[i,j] <- delnice[i,j]/delnice[i-1,j]
i <- i-1
}
if (delnice[i,j]==0) {
delnice[i+1,j] <- 1
}
else {delnice[i,j] <- 1}
}
View(trade)
View(delnice)
dnevi <- 90 #koliko dnevni sharpov index računamo
sharp <- delnice
for (j in 4:(length(delnice[1,])-1)) { #do -1, ker zadnji stolpec je benchmark!
k <- 1
while (delnice[k,j] == 0) { #začnemo pri tistem k-ju, ko delnica začne kotirati na borzi
k <- k+1
}
for (i in (k+dnevi):length(delnice[,1])) {
sharp[i,j] <- mean(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])])/sd(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]) #length(delnice[1,]), ker zadnji stolpec je benchmark
}
for (i in 1:(k+dnevi-1)) {sharp[i,j] <- NA}
}
dnevi <- 90 #koliko dnevni sharpov index računamo
start.time <- Sys.time()
sharp <- delnice
for (j in 4:(length(delnice[1,])-1)) { #do -1, ker zadnji stolpec je benchmark!
k <- 1
while (delnice[k,j] == 0) { #začnemo pri tistem k-ju, ko delnica začne kotirati na borzi
k <- k+1
}
for (i in (k+dnevi):length(delnice[,1])) {
sharp[i,j] <- mean(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])])/sd(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]) #length(delnice[1,]), ker zadnji stolpec je benchmark
}
for (i in 1:(k+dnevi-1)) {sharp[i,j] <- NA}
}
start.time <- Sys.time()
sharp <- delnice
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
dnevi <- 90 #koliko dnevni sharpov index računamo
start.time <- Sys.time()
sharp <- delnice
for (j in 4:(length(delnice[1,])-1)) { #do -1, ker zadnji stolpec je benchmark!
k <- 1
while (delnice[k,j] == 0) { #začnemo pri tistem k-ju, ko delnica začne kotirati na borzi
k <- k+1
}
for (i in (k+dnevi):length(delnice[,1])) {
sharp[i,j] <- mean(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])])/sd(delnice[(i-(dnevi-1)):i,j]-delnice[(i-(dnevi-1)):i,length(delnice[1,])]) #length(delnice[1,]), ker zadnji stolpec je benchmark
}
for (i in 1:(k+dnevi-1)) {sharp[i,j] <- NA}
}
View(sharp)
View(delnice)
View(invest)
write.csv2(delnice,file="C:/zan/faks/opb/ODP/delnice.csv") #tabela s procentualnimi spremambami kotiranja delnic
write.csv2(delnice,file="C:/zan/faks/opb/ODP/delnice.csv") #tabela s procentualnimi spremambami kotiranja delnic
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8', echo=TRUE)
View(delnice)
View(invest)
View(sharp)
View(trade)
n <- length(delnice$leto == 2010)
n
n <- length(which(delnice$leto==2010))
n
View(delnice)
View(trade)
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8', echo=TRUE)
View(trade)
